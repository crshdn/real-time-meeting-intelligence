# Real-Time Sales Conversation Assistant

## Project Overview

A desktop application that listens to live sales calls (Zoom, Teams, Google Meet), transcribes in real-time, and provides AI-generated response suggestions displayed in an overlay.

## Tech Stack

### Backend (Python)
- **Audio Capture**: `sounddevice` / `pyaudiowpatch` (WASAPI on Windows, BlackHole on macOS)
- **Speech-to-Text**: Deepgram streaming WebSocket API
- **LLM**: Anthropic Claude API (claude-sonnet-4-20250514)
- **IPC**: WebSocket server (localhost:8765)

### Frontend (Electron + React + TypeScript)
- **Framework**: Electron for desktop
- **UI**: React with TypeScript
- **Styling**: Tailwind CSS or styled-components
- **State**: React hooks or Zustand

## Architecture

```
User's Computer
├── Audio Capture Module (Python)
│   └── Captures system audio + microphone
├── Audio Buffer & Streaming
│   └── 16kHz, 16-bit PCM, 250ms chunks
├── Deepgram WebSocket
│   └── Real-time transcription with diarization
├── Conversation Context Manager
│   └── Rolling 3-minute buffer, trigger detection
├── Claude API
│   └── Generate response suggestions
└── Electron Overlay UI
    └── Always-on-top, transparent, draggable
```

## Directory Structure

```
real-time-meeting-intelligence/
├── backend/
│   ├── main.py              # Entry point
│   ├── audio_capture.py     # System audio capture
│   ├── transcription.py     # Deepgram integration
│   ├── context_manager.py   # Conversation buffer
│   ├── llm_generator.py     # Claude API integration
│   ├── websocket_server.py  # IPC with frontend
│   └── requirements.txt
├── ui/
│   ├── src/
│   │   ├── main/           # Electron main process
│   │   ├── renderer/       # React components
│   │   └── shared/         # Shared types
│   ├── package.json
│   └── electron-builder.json
├── config/
│   └── playbook.json       # User's sales playbook
├── .env.example
├── SPEC.md
└── README.md
```

## Key Commands

### Backend
```bash
# Install dependencies
pip install -r backend/requirements.txt

# Run backend server
python backend/main.py

# Run with debug logging
DEBUG=1 python backend/main.py
```

### Frontend
```bash
# Install dependencies
cd ui && npm install

# Development mode
npm run dev

# Build for production
npm run build

# Package application
npm run package
```

### Testing
```bash
# Backend tests
pytest backend/tests/

# Frontend tests
cd ui && npm test

# E2E tests
npm run test:e2e
```

## Environment Variables

```
DEEPGRAM_API_KEY=your-deepgram-key
ANTHROPIC_API_KEY=your-anthropic-key
DEBUG=0
AUDIO_DEVICE_INDEX=auto
WEBSOCKET_PORT=8765
```

## API Endpoints (WebSocket)

### Backend → Frontend Messages
- `{ "type": "transcript", "text": "...", "speaker": "prospect|salesperson", "is_final": true }`
- `{ "type": "suggestions", "items": ["...", "...", "..."] }`
- `{ "type": "status", "listening": true, "connected": true }`

### Frontend → Backend Messages
- `{ "type": "start_listening" }`
- `{ "type": "stop_listening" }`
- `{ "type": "update_playbook", "playbook": {...} }`

## Development Guidelines

1. **Latency is critical** - End-to-end response time must be under 5 seconds
2. **Privacy first** - Never store raw audio; transcripts optional
3. **Unobtrusive UI** - Overlay should not interfere with screen sharing
4. **Error resilience** - Handle network drops, API failures gracefully
5. **Cross-platform** - Test on both Windows and macOS

## Common Patterns

### Audio Callback Pattern
```python
def audio_callback(indata, frames, time, status):
    if status:
        logger.warning(f"Audio status: {status}")
    audio_queue.put(indata.copy())
```

### Trigger Detection
```python
trigger_phrases = [
    "too expensive", "not sure", "competitor",
    "think about it", "not the right time", "budget"
]
```

### Claude System Prompt Structure
- Role definition
- Product context
- Objection playbook
- Conversation transcript
- Instructions for response format

## Security Considerations

- Store API keys encrypted (use keyring or OS keychain)
- Warn about screen share visibility
- Add recording consent disclaimer
- Support local-only mode option


<claude-mem-context>
# Recent Activity

<!-- This section is auto-generated by claude-mem. Edit content outside the tags. -->

*No recent activity*
</claude-mem-context>